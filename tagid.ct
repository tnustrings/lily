# tagid

<<//tagid.go
package main

<<import>>
<<hello>>
<<main>>
<<tagid>>
<<words-and-between>>
<<lookup>>

<<split-keep>>
>>

hello returns a greeting.

<</hello
func Hello() string {
  message := fmt.Sprintf("hi")
  return message
}
>>

import fmt.

<</import
import "fmt"
>>

<</main
// main runs Hello.
func main() {
  <<.>>
}
>>

open the dict file

<<
  gtdictfile := "gt-scrape-dict.json"

  file, err := os.Open(gtdictfile)
  if err != nil {
    fmt.Println(err)
  }
  defer file.Close()
>>

unmarshal the json

<<
  bytes, _ := io.ReadAll(file)

  var dict map[string]interface{}
  json.Unmarshal([]byte(bytes), &dict)
>>

read the text.

<<
  bytes, _ = io.ReadAll(os.Stdin)
>>

set the lang.

<<
  langa := os.Args[1]
>>

output the text with word by word translations.

<<
  fmt.Println(Tagid(string(bytes), langa, dict))
  //fmt.Println(dict["de"].(map[string]interface{})["hallo"])
>>

do the imports.

<</import
import "os"
import "encoding/json"
import "io"
>>

## tagid

<</tagid
// Tagid puts word-by-word translations into text
func Tagid(text string, langa string, dict map[string]interface{}) string {
  <<.>>
}
>>

get the words and what's in between.

<<
  wab := WordsAndBetween(text)
>>

iterate the words and between-strings, if it's a non-word, append.

<<
  out := ""
  hasLetter := regexp.MustCompile(`\p{L}`)
  for _, w := range wab {
    if !hasLetter.MatchString(w) {
      out += w
    } else {
      <<.>>
    }
  }
  return out
>>

it seems to be a word, look it up.

<<
insert := ""
insert = Lookup(dict, langa, w)
>>

first append the word, then the looked up insert.  empty insert
strings are ok, so that formatting is consistent.

<<
out += w
out += " [[" + insert + "]]"
>>

<</import
import "regexp"
>>

## lookup

<</lookup
// Lookup looks up a word in dict
func Lookup(dict map[string]interface{}, lang string, word string) string {
  <<.>>
}
>>

lower the string.

<<
  word = strings.ToLower(word)
>>

check if the dict for the language is there.

apparently the standard behaviour for 'not found' is not to return nil
but to return empty strings: https://go.dev/doc/tutorial/handle-errors

<<
  val, ok := dict[lang]
  // no dict for lang
  if !ok { return "" }
>>

look up the word

<<
  val, ok = dict[lang].(map[string]interface{})[word]
  // word not in dict
  if !ok { return "" }

  return val.(string)
>>

<</import
import "strings"
>>

## words and between

<</words-and-between
// WordsAndBetween splits the text into words and non-words
func WordsAndBetween(s string)[]string {
  <<.>>
}
>>

the intuitive way would be to split along the non-letters between
words: [^\p{L}\p{M}]+

however, this would split up words containing apostrophes like "don't"
into "don", "'", "t".  we don't want this.

so we split along the words, that means, groups of letters possibly
containing an apostrophe, but not beginnig or ending with one:
[\p{L}\p{M}]+'?[\p{L}\p{M}]

<<
  re := regexp.MustCompile(`[\p{L}\p{M}]+'?[\p{L}\p{M}]+`)
  return SplitKeepSep(re, s)
>>

split with keeping the delimiter.

<</split-keep
func SplitKeepSep(re *regexp.Regexp, s string) []string {
  <<.>>
}
>>

get the match indices.

<<
matches := re.FindAllStringIndex(s, -1)
>>

append the string leading up to the next match and then the match.

<<
var out []string
start := 0
for _, match := range matches {
  out = append(out, s[start:match[0]])
  out = append(out, s[match[0]:match[1]])
  // the next starts after match
  start = match[1]
}
>>

append the string from the last match till the end and return.

<<
if start < len(s) {
  out = append(out, s[start:len(s)-1])
}
return out
>>

